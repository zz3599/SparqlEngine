% -*- Mode: Prolog -*-
% Useful utilities for prolog 

%------------------------Arithmetic--------------------
close_enough(X,X) :- ! .
close_enough(X,Y) :- X < Y, Y-X < 0.0001.
close_enough(X,Y) :- Y < X, close_enough(Y,X).

real_sqrt(X,Y) :- X >= 0.0, R is sqrt(X), close_enough(R,Y).
real_sqrt(X,none) :- X < 0.0.

max(X,Y,Z) :- X=<Y, !, Z=Y.
max(X,_,X).

min(X,Y,Z) :- X>=Y, !, Z=Y.
min(X,_,X).


% ----------------------LIST OPERATIONS--------------------------
% member(X, List)
member(X, [X|_]).
member(X, [_|Rest]) :- member(X, Rest).

% append(X,Y,Z) :- Z is X + Y
append([], X, X).
append([X1|X2], Y, [X1|Z]) :- append(X2,Y,Z).

% list_length(List, Length) - use an accumulator to save stack space
% Tail call/last call optimization
list_length(List, Length) :- list_length(List, 0, Length).
list_length([], C, C).
list_length([X|Y], C, L) :- C2 is C+1, list_length(Y, C2, L).

% count_occurrences(Element, List, Number) :- Stores the number of times E appears in List in Number
count_occurrences(_, [], 0).
count_occurrences(X, [X|Rest], N) :- !, count_occurrences(X, Rest, N1), N is N1+1.
count_occurrences(X, [Y|Rest], N) :- count_occurrences(X, Rest, N).

% lastelement(List, Last) :- Unifies Last to the last element of List
lastelement([A],A).
lastelement([_|Rest], E) :- lastelement(Rest, E).

% flatten(List, Result) : Flattens a list into only its constituents
flatten([],[]).
flatten([X|Rest],Result) :- 
    flatten(X, Result1), 
    flatten(Rest, Result2), 
    append(Result1, Result2, Result).
flatten(X, Result) :- atomic(X), Result =[X]. % handle atoms
flatten([X|Rest], Result) :- flatten(Rest, Result2), append([X], Result2, Result). % handle lists 

% Use stack to save appends 
reverse(Original, Result) :-
    nonvar(Original),
    reverse(Original, [], Result).
reverse([], Stack, Stack).
reverse([H|T], Stack, Result) :- reverse(T, [H|Stack], Result).

% Remove X from list 
remove(X, [X|Y], Y).
remove(X, [Y|Z], [Y|W]) :- remove(X, Z, W).

% Remove all occurrences 
removeall(X, [], []).
removeall(X, [X|Y], Z) :- !, removeall(X, Y, Z).
removeall(X, [Y|Z], [Y|W]) :- removeall(X, Z, W).
    
% Union arg1 arg2 into arg3
union([], X, X).
union([X|More], Y, Z) :- member(X, Y), !, union(More, Y, Z). 
union([X|More], Y, [X|Z]) :- union(More, Y, Z).

% Intersection of arg1 and arg2 
intersection([], X, []).
intersection([X|More], Y, [X|Z]) :- member(X, Y), !, intersection(More, Y, Z).
intersection([X|More], Y, Z) :- intersection(More, Y, Z).

% subtract(X,Y,Z) :- Z is Y \setdiff X
subtract([], X, X).
subtract([X|More], Y, Z) :- remove(X, Y, W), !, subtract(More, W, Z). % If X was removed, cannot backtrack
subtract([X|More], Y, Z) :- subtract(More, Y, Z).

% ----------------------IO--------------------------------------------------
% write_str(String) : By default input of "X" will output [ASCII(X)], so this will instead print out the literal
write_str([]).
write_str([H|T]) :- put(H), write_str(T).

print_splits(String) :- 
    nonvar(String),
    print_splits(String, []).
print_splits([], Front) :- write_str(Front), nl.
print_splits([H|T], Front) :- 
    write_str(Front), write_str(" "), write_str([H|T]), nl, 
    append(Front, [H], F2),
    print_splits(T, F2).

% read_str(A) : unifies A to a list of charcodes
read_str(String) :- get0(Char), read_str_aux(Char, String).
read_str_aux(-1, []) :- !.
read_str_aux(13, []) :- !.
read_str_aux(10, []) :- !.
read_str_aux(Char, [Char|Rest]) :- read_str(Rest).

% read_atom(A) : unifies A with input
read_atom(Atom) :-
    read_str(String), name(Atom, String).

% read_charlist(A): Unifies A to a list of chars
read_charlist(Charlist) :- get0(Char), read_charlist_aux(Char, Charlist).
read_charlist_aux(-1, []) :- !.
read_charlist_aux(13, []) :- !.
read_charlist_aux(10, []) :- !.
read_charlist_aux(C, [Char|Rest]) :- char_code(Char, C), read_charlist(Rest).

% read_str_no_blanks(String) :- Get input without blanks
read_str_no_blanks(String) :- get0(Char), read_str_no_blanks_aux(Char, String).
read_str_no_blanks_aux(-1, []) :- !.
read_str_no_blanks_aux(10, []) :- !.
read_str_no_blanks_aux(13, []) :- !.
read_str_no_blanks_aux(Char, Rest) :- Char is 32, read_str_no_blanks(Rest).
read_str_no_blanks_aux(Char, [Char|Rest]) :- read_str_no_blanks(Rest).

% functor(arg3,arg2,arg1) => functor(arg1, arg2, arg3)
reverse_functor_args(Input, Result) :- 
    Input =.. [H|Args], 
    fastreverse(Args, ReversedArgs), 
    append([H], ReversedArgs, ResultList), 
    Result =.. ResultList.

% Gets the Indexth arg of the functor, stored in Result
nth_arg(Functor, Index, Result) :- 
    functor(Functor, _, Arity),
    Arity >= Index, 
    arg(Index, Functor, Result).

% Calls the predicate 'functor(argslist)'
apply(Functor, Argslist) :-
    Query =.. [Functor|Argslist], 
    call(Query).


% map(functor, list, result)
% Functor is 2 argument predicate, 
map(Functor, [H|T], Stack, Result) :-
    apply(Functor, [H,Who]), 
    write(Who), nl,
    map(Functor, T, [Who|Stack], Result).
map(Functor, [], Stack, Result) :-
    reverse(Stack, Result).
map(Functor, List, Result) :-
    var(Result), !,
    map(Functor, List, [], Result).


%map(Functor, [H1|T1], [H2|T2]) :- !.
%    apply(Functor, 
% Test data
capital_of(georgia, atlanta).
capital_of(california, sacramento).
capital_of(florida, tallahassee).
capital_of('new york', albany).

%--------------------------------PARSING----------------------------
% Tokenize(String, Output) - splits the string to lowercase tokens to assert 
tokenize([], []) :- !.
tokenize(String, [Word|Rest]) :-
    grab_word(String, Chars, NewString),
    name(Word, Chars),
    tokenize(NewString, Rest).

grab_word([32|Tail], [], Tail) :- !. % Space = separator
grab_word([],[],[]).

%grab_word([Char|Tail] ,Chars, Rest) :-
%    punctuation(Char), !,
%    grab_word(Tail, Chars, Rest).

grab_word([Char|Tail1], [NewChar|Tail2], Rest) :-
    grab_word(Tail1, Tail2, Rest), 
    lowercase(Char, NewChar).

punctuation(Char) :- Char =< 7.
punctuation(Char) :- Char >= 58, Char =< 64.
punctuation(Char) :- Char >= 91, Char =< 96.
punctuation(Char) :- Char >= 123.

lowercase(Char,NewChar) :-
    Char >= 65, Char =< 90, !,
    NewChar is Char+32.
lowercase(Char, Char).

classify(Num) :- R is Num mod 2, classify_(R).
classify_(1) :- !, write_str("odd"), nl.
classify_(0) :- !, write_str("even"), nl.
classify_(_) :- write_str("not integer"), nl.

sum(X,Y,Result) :- sum(X,Y,0,Result).
sum(X,Y,Store, Store) :- X > Y, !.
sum(X,Y,Store, Result) :- 
    Store2 is Store + X,
    X2 is X + 1,
    sum(X2, Y, Store2, Result).

test(N) :- write(N), nl, NewN is N+1, test(NewN).
test2(N) :- write(N), nl, NewN is N+1, test2(NewN), nl.